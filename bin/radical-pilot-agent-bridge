#!/usr/bin/env python3

import sys
import zmq
import time
import queue

import threading       as mt
import multiprocessing as mp
import radical.utils   as ru


_TIMEOUT         =   300  # time to keep the bridge alive
_LINGER_TIMEOUT  =   250  # ms to linger after close
_HIGH_WATER_MARK =     0  # number of messages to buffer before dropping
                          # 0:  infinite


# ------------------------------------------------------------------------------
# This ZMQ bridge links clients and agents, and bridges network gaps.  As such
# it needs to run on a resource which has a public IP address that can be
# reached from both the client and the server machine.
#
# The bridge listens on a `REP` socket (`bridge_request`) for incoming client or
# agent connections, identified by a common session ID.  A client connection
# will trigger the creation of the following communication channels:
#
#   - control_pubsub_bridge
#     links client and agent control pubsubs (includes heartbeat)
#   - state_pubsub_bridge
#     forwards task state updates from agents to client
#   - agent_input_queue
#     forwards tasks from the client to the agents
#   - agent_output_queue
#     forwards tasks from the agents to the client
#
#
# The protocol on the `bridge_request` channel is as follows:
#
# client_register
# ---------------
#
#    request:
#       'cmd': 'client_register'
#       'arg': 'sid': <sid>
#
#    reply:
#       'res': {'control_pubsub'    : {'sub': <url>, 'pub': <url>},
#               'state_pubsub'      : {'sub': <url>, 'pub': <url>},
#               'agent_input_queue' : {'put': <url>, 'get': <url>},
#               'agent_output_queue': {'put': <url>, 'get': <url>}}
#
#    notes:
#      - the request will fail if the session ID is known from another
#        `client_register` call
#        'err': 'sid already connected'
#      - this request should otherwise always succeed
#      - the created pubsub channels will be terminated if the control channel
#        has not seen a client heartbeat for <10 * heartbeat_interval> seconds
#        - see semantics of the 'client_unregister' request for details.
#      - the same termination semantics holds for the 'client_unregister'
#        request.
#      - any agent queues which exist for that session at the time of
#        termination will also be closed, disregarding ay data hekd in those
#        queues.
#
#
# client_lookup
# ---------------
#
#    request:
#       'cmd': 'client_lookup'
#       'arg': 'sid': <sid>
#
#    reply:
#       'res': {'control_pubsub'    : {'sub': <url>, 'pub': <url>},
#               'state_pubsub'      : {'sub': <url>, 'pub': <url>},
#               'agent_input_queue' : {'put': <url>, 'get': <url>},
#               'agent_output_queue': {'put': <url>, 'get': <url>}}
#
#    notes:
#      - the request will fail if the session ID is not registered (anymore)
#      - this request should otherwise always succeed
#      - the call returns the same information as `client_register`, but does
#        not alter the state of the client's bridge in any other way.
#      - the request does not count as a heartbeat
#
#
# client_unregister
# -----------------
#
#    request:
#       'cmd': 'client_unregister'
#       'arg': 'sid': <sid>
#
#    reply:
#       'res': 'ok'
#
#   - this method only fails when the session is not connected, with
#     'err': 'session not connected'
#   - in all other cases, the request will cause the immediate termination of
#     all ZMQ bridges (pubsubs and queues) previously created for that
#     session, disregarding of their state, and disposing all undelivered
#     messages still held in the bridges.
#
#
# client_heartbeat
# ----------------
#
#    request:
#      'cmd': 'client_heartbeat'
#      'arg': 'sid': <sid>
#
#    reply:
#      'res': {'time': <heartbeat timestamp>}
#
# notes:
#    - this request will fail if the session is either not connected or timed
#      because of an earlier heartbeat failure:
#      'err': 'session not connected'
#    - it will otherwise ensure the server that the client is still alive and
#      requires the bridge to be up.  If the server does not receive a heartbeat
#      for longer than TIMEOUT seconds, the bridge will be terminated.
#
#
# default error mode
# ------------------
#
# To any request other than the above, the ZMQ bridge will respond:
#      'err': 'invalid request'
#
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
#
class ZMQBridge(ru.zmq.Server):

    def __init__(self):

        self._lock    = mt.Lock()
        self._clients = dict()

        ru.zmq.Server.__init__(self)

        self._monitor = mt.Thread(target=self._monitor)
        self._monitor.daemon = True
        self._monitor.start()

        self.register_request('client_register',   self._client_register)
        self.register_request('client_lookup',     self._client_lookup)
        self.register_request('client_unregister', self._client_unregister)
        self.register_request('client_heartbeat',  self._client_heartbeat)


    # --------------------------------------------------------------------------
    #
    def _monitor(self):

        # this is a daemon thread - it never exits until process termination
        while True:

            time.sleep(10)
            now  = time.time()

            # iterate w/o lock, and thus get a snapshot of the known sids
            sids = list(self._clients.keys())

            to_terminate = list()
            for sid in sids:

                client = self._clients.get(sid)
                if not client:
                    continue

                if now > (client['hb'] + _TIMEOUT):
                    self._log.warn('client %s timed out' % sid)
                    to_terminate.append(sid)

            if not to_terminate:
                continue

            with self._lock:

                for sid in to_terminate:

                    client = self._clients.get(sid)
                    if not client:
                        continue

                    client['term'].set()
                    client['proc'].join()
                    del(self._clients[sid])


    # --------------------------------------------------------------------------
    #
    def stop(self):

        for sid in self._clients:
            self._clients[sid]['term'].set()

        ru.zmq.Server.stop(self)


    # --------------------------------------------------------------------------
    #
    def _client_register(self, arg):

        sid = arg['sid']

        if sid in self._clients:
            return {'err': 'client already registered'}

        q = mp.Queue()
        term = mp.Event()
        proc = mp.Process(target=self._worker, args=[sid, q, term])
        proc.start()

        try:
            data = q.get(timeout=10)
        except queue.Empty:
            proc.terminate()
            return {'err': 'worker startup failed'}

        self._clients[sid] = {'proc': proc,
                              'term': term,
                              'data': data,
                              'hb'  : time.time()}

        return {'res': self._clients[sid]['data']}


    # --------------------------------------------------------------------------
    #
    def _worker(self, sid, q, term):

        log = ru.Logger('radical.pilot.bridge', level='debug', path=sid)

        control_pubsub = None
        state_pubsub   = None
        agent_queue    = None

        try:
            control_pubsub = ru.zmq.PubSub(cfg={'channel': 'control_pubsub',
                                                'uid'    : 'control_pubsub',
                                                'type'   : 'pubsub',
                                                'path'   : sid})

            state_pubsub   = ru.zmq.PubSub(cfg={'channel': 'state_pubsub',
                                                'uid'    : 'state_pubsub',
                                                'type'   : 'pubsub',
                                                'path'   : sid})

            agent_queue    = ru.zmq.Queue (cfg={'channel': 'agent_queue',
                                                'uid'    : 'agent_queue',
                                                'type'   : 'queue',
                                                'path'   : sid})

            control_pubsub.start()
            state_pubsub.start()
            agent_queue.start()

            data = {'control_pubsub'    : {'pub': str(control_pubsub.addr_pub),
                                           'sub': str(control_pubsub.addr_sub)},
                    'state_pubsub'      : {'pub': str(state_pubsub.addr_pub),
                                           'sub': str(state_pubsub.addr_sub)},
                    'agent_queue'       : {'put': str(agent_queue._addr_put),
                                           'get': str(agent_queue._addr_get)}}

            # inform service about endpoint details
            q.put(data)

            # we run forever until we receive a termination command
            log.info('work')
            term.wait()


        except:
            log.exception('worker failed')

        finally:

            if control_pubsub: control_pubsub.stop()
            if state_pubsub  : state_pubsub.stop()
            if agent_queue   : agent_queue.stop()

            log.info('terminated')


    # --------------------------------------------------------------------------
    #
    def _client_lookup(self, arg):

        sid = arg['sid']

        with self._lock:
            if sid not in self._clients:
                return {'err': 'client not registered'}

            return {'res': self._clients[sid]['data']}


    # --------------------------------------------------------------------------
    #
    def _client_unregister(self, arg):

        sid = arg['sid']

        with self._lock:

            if sid not in self._clients:
                return {'err': 'client not registered'}

            self._clients[sid]['term'].set()
            self._clients[sid]['proc'].join()

            del(self._clients[sid])

        return {'res': 'ok'}


    # --------------------------------------------------------------------------
    #
    def _client_heartbeat(self, arg):

        sid = arg['sid']
        now = time.time()

        with self._lock:

            if sid not in self._clients:
                return {'err': 'client not registered'}

            self._clients[sid]['hb'] = now

        return {'res': 'ok'}


# ------------------------------------------------------------------------------
#
if __name__ == '__main__':

    bridge = ZMQBridge()

    try:
        sys.stdout.write('uid : %s\n' % bridge.uid)
        sys.stdout.flush()

        bridge.start()

        sys.stdout.write('addr: %s\n' % bridge.addr)
        ru.write_json('%s.cfg' % bridge.uid, {'addr': bridge.addr})

        # run forever until process is interrupted or killed
        while True:
            time.sleep(1)

    finally:
        print('final')
        bridge.stop()
        print('stopped')
        bridge.wait()
        print('waited')


# ------------------------------------------------------------------------------

